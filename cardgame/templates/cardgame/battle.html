<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="Card battle system for EcoSplore">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoSplore Battle</title>
    {% load static %}
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Kanit', Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Navbar Styles */
        .navbar {
            display: flex;
            height: 50px;
            align-items: center;
            background: linear-gradient(90deg, rgba(106,149,37,1) 0%, rgba(9,121,12,1) 35%);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            padding: 15px 30px;
            justify-content: space-between;
        }

        .logo img {
            height: 45px;
        }

        .nav-links {
            display: flex;
            align-items: center;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            padding: 10px 15px;
            margin: 0 5px;
            border-radius: 5px;
            transition: background-color 0.2s ease-in-out;
            text-shadow: 2px 2px 5px gray;
        }

        .nav-links a:hover {
            background-color: #0fce14;
        }

        /* Battle Container Styles */
        .battle-container {
            max-width: 1000px;
            margin: 30px auto;
            padding: 20px;
            flex: 1;
        }

        .battle-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .battle-header h1 {
            color: #08546B;
            font-size: 32px;
            margin-bottom: 10px;
        }

        .battle-status {
            color: #0c82a3;
            font-size: 18px;
            margin-bottom: 20px;
        }

        /* Card Styles */
        .card {
            width: 140px;
            height: 200px;
            border: 2px solid #ccc;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-5px) scale(1.03);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
            border-color: #12c5f8;
        }

        .card.selected {
            border-color: #0fce14;
            background: linear-gradient(135deg, #f0fff0 0%, #e0ffe0 100%);
        }

        /* Battle Area Styles */
        .battle-area {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .player-area, .opponent-area {
            border: 3px solid #12c5f8;
            border-radius: 10px;
            padding: 20px;
            background: linear-gradient(0deg, #ffffff 0%, #f0f0f0 100%);
        }

        /* Card Stats Styles */
        .card-stats {
            text-align: left;
            font-size: 12px;
            margin-top: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 5px;
            border-radius: 3px;
            cursor: pointer;
        }

        .stat-row:hover {
            background-color: #e8f4f8;
        }

        /* Battle Log Styles */
        #battle-log {
            height: 200px;
            border: 2px solid #12c5f8;
            border-radius: 10px;
            overflow-y: auto;
            padding: 15px;
            margin-top: 30px;
            background-color: #f9f9f9;
        }

        .log-entry {
            padding: 8px 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            animation: fadeIn 0.3s ease;
        }

        /* Result Overlay Styles */
        .result-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .result-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Footer Styles */
        .footer {
            display: flex;
            height: 30px;
            background: linear-gradient(90deg, rgba(106,149,37,1) 0%, rgba(9,121,12,1) 35%);
            align-items: center;
            justify-content: center;
            box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.2);
            margin-top: auto;
        }

        .footer p {
            color: white;
            margin: 0;
        }

        /* Button Styles */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background-color: #12c5f8;
            color: white;
        }

        .btn-primary:hover {
            background-color: #0c82a3;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Add at the end of your style section */
        .active-turn {
            border: 3px solid #0fce14;
            box-shadow: 0 0 15px rgba(15, 206, 20, 0.5);
        }

        .stat-row.selectable {
            background-color: rgba(15, 206, 20, 0.1);
            cursor: pointer;
        }

        .stat-row.selectable:hover {
            background-color: rgba(15, 206, 20, 0.3);
        }

        .stat-row.highlight {
            background-color: #12c5f8;
            color: white;
            font-weight: bold;
        }

        .result-content {
            background: white;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
        }

        .result-title {
            font-size: 32px;
            margin-bottom: 15px;
            color: #08546B;
        }

        .result-message {
            font-size: 18px;
            margin-bottom: 25px;
        }
    </style>
</head>
<body>
    <header class="navbar">
        <a href="/home" class="logo">
            <img src="{% static 'img/logo.png' %}" alt="EcoSplore Logo">
        </a>
        <nav class="nav-links">
            <a href="/home">Home</a>
            <a href="/profile-redirect">Profile</a>
            <a href="/challenges">Challenges</a>
            <a href="/collection-redirect">Collection</a>
            <a href="/logout">Sign Out</a>
        </nav>
    </header>

    <div class="battle-container">
        <div class="battle-header">
            <h1>Card Battle</h1>
            <div class="battle-status">Room ID: {{ room_id }} - Share this with your opponent!</div>
        </div>

        <div id="card-selection" class="card-selection" style="display:none;">
            <h2>Select 4 cards for your battle deck</h2>
            <div id="card-selection-grid" class="card-selection-grid">
                <!-- Cards will be loaded here -->
            </div>
            <div class="battle-actions">
                <button id="confirm-selection" class="btn btn-primary" disabled>
                    Confirm Selection (<span id="selected-count">0</span>/4)
                </button>
            </div>
        </div>

        <div id="battle-area" class="battle-area" style="display:none;">
            <div class="opponent-area">
                <div class="area-header">
                    <h2>Opponent: <span id="opponent-name">Waiting...</span></h2>
                    <div class="score">Score: <span id="opponent-score">0</span></div>
                </div>
                <div id="opponent-cards" class="cards-container">
                    <!-- Opponent cards will appear here -->
                </div>
            </div>

            <div class="player-area">
                <div class="area-header">
                    <h2>Your Cards</h2>
                    <div class="score">Score: <span id="player-score">0</span></div>
                </div>
                <div id="player-cards" class="cards-container">
                    <!-- Player cards will appear here -->
                </div>
            </div>
        </div>

        <div id="battle-log">
            <div class="log-entry">Welcome to EcoSplore Battle! Waiting for opponent...</div>
        </div>
    </div>

    <div id="result-overlay" class="result-overlay">
        <div class="result-content">
            <div id="result-title" class="result-title">Victory!</div>
            <div id="result-message" class="result-message">You won the battle!</div>
            <div class="result-actions">
                <button id="new-battle" class="btn btn-primary">New Battle</button>
                <a href="/home" class="btn btn-success">Return Home</a>
            </div>
        </div>
    </div>

    <footer class="footer">
        <p>@Copyright 2025. All rights reserved.</p>
    </footer>

    <script>
        // Get username and room from template context
        const username = "{{ username }}";
        const roomId = "{{ room_id }}";
        let socket;
        let selectedCards = [];
        let gameState = "waiting"; // waiting, selecting, playing, completed
        let isMyTurn = false;
        let currentRound = 1;
        // Add this variable to track which player the client is
        let isPlayer1 = true;
        let firstCardRendered = false;
        
        // Connect to WebSocket
        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            socket = new WebSocket(`${protocol}//${host}/ws/battle/${roomId}/`);
            
            // Connection opened
            socket.addEventListener('open', (event) => {
                logMessage('Connected to battle server!');
            });
            
            // Listen for messages
            socket.addEventListener('message', (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            });
            
            // Connection closed
            socket.addEventListener('close', (event) => {
                logMessage('Disconnected from battle server.');
                setTimeout(connect, 1000);
            });
            
            // Connection error
            socket.addEventListener('error', (event) => {
                logMessage('WebSocket error occurred');
            });
        }
        
        // Handle incoming messages
        function handleMessage(data) {
            console.log("Received message:", data);
            
            switch(data.event) {
                case 'battle_created':
                    logMessage('Battle room created. Waiting for an opponent to join...');
                    gameState = "waiting";
                    isPlayer1 = true; // Creator is player 1
                    break;
                    
                case 'battle_joined':
                    logMessage('You joined the battle!');
                    transitionToCardSelection();
                    isPlayer1 = false; // Joiner is player 2
                    break;
                    
                case 'battle_rejoined':
                    logMessage('Reconnected to battle!');
                    // Handle reconnection based on battle state
                    break;
                    
                case 'user_connected':
                    logMessage(`${data.username} has joined the battle!`);
                    document.getElementById('opponent-name').textContent = data.username;
                    if (gameState === "waiting") {
                        transitionToCardSelection();
                    }
                    break;
                    
                case 'cards_selected':
                    logMessage(`${data.username} has selected their cards`);
                    if (data.username !== username) {
                        document.getElementById('opponent-name').textContent = data.username;
                    }
                    break;
                    
                case 'player_ready':
                    logMessage(`${data.username} is ready to battle!`);
                    if (data.both_ready && data.battle_status === 'in_progress') {
                        logMessage('Both players ready! The battle begins!');
                        transitionToBattle(data.first_turn || 1);
                    }
                    break;
                    
                case 'round_result':
                    displayRoundResult(data);
                    break;
                    
                case 'battle_completed':
                    displayBattleResult(data);
                    break;
                    
                case 'error':
                    logMessage(`Error: ${data.message}`, true);
                    break;
                    
                case 'current_cards':
                    renderInitialCards(data);
                    break;
                    
                default:
                    logMessage(`Received event: ${data.event}`);
            }
        }
        
        // Transition to card selection phase
        function transitionToCardSelection() {
            gameState = "selecting";
            
            // Show card selection UI
            document.getElementById('card-selection').style.display = 'block';
            document.getElementById('battle-area').style.display = 'none';
            
            // Load player's available cards
            fetchAvailableCards();
        }
        
        // Fetch available cards from user's collection
        function fetchAvailableCards() {
            fetch(`/get-battle-cards/`)
                .then(response => response.json())
                .then(data => {
                    const grid = document.getElementById('card-selection-grid');
                    grid.innerHTML = '';
                    
                    data.cards.forEach(card => {
                        const cardElement = createCardElement(card, true);
                        cardElement.addEventListener('click', () => toggleCardSelection(cardElement, card));
                        grid.appendChild(cardElement);
                    });
                })
                .catch(error => {
                    logMessage('Error loading your cards. Please refresh.', true);
                    console.error('Error:', error);
                });
        }
        
        // Toggle card selection
        function toggleCardSelection(cardElement, card) {
            if (selectedCards.includes(card.name)) {
                // Deselect card
                cardElement.classList.remove('selected');
                selectedCards = selectedCards.filter(name => name !== card.name);
            } else if (selectedCards.length < 4) {
                // Select card
                cardElement.classList.add('selected');
                selectedCards.push(card.name);
            }
            
            // Update counter and button state
            document.getElementById('selected-count').textContent = selectedCards.length;
            document.getElementById('confirm-selection').disabled = selectedCards.length !== 4;
        }
        
        // Confirm card selection
        function confirmCardSelection() {
            if (selectedCards.length !== 4) return;
            
            if (socket && socket.readyState === WebSocket.OPEN) {
                const message = {
                    event: 'select_cards',
                    card_ids: selectedCards
                };
                socket.send(JSON.stringify(message));
                
                // Signal ready to start
                socket.send(JSON.stringify({ event: 'ready' }));
                
                logMessage("Cards selected and ready to battle!");
                document.getElementById('confirm-selection').disabled = true;
            }
        }
        
        // Transition to battle phase
        function transitionToBattle(firstTurn) {
            gameState = "playing";
            
            // Hide card selection, show battle area
            document.getElementById('card-selection').style.display = 'none';
            document.getElementById('battle-area').style.display = 'block';
            
            // Determine if it's this player's turn based on player identity
            isMyTurn = (firstTurn === 1 && isPlayer1) || (firstTurn === 2 && !isPlayer1);
            
            // Update UI to reflect current turn
            updateTurnIndicator();
            
            // Request the first card to be shown
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    event: 'request_current_cards'
                }));
            }
            
            logMessage("Battle started! " + (isMyTurn ? "Your turn first." : "Opponent goes first."));
        }
        
        // Render player's cards in battle area
        function renderPlayerCards() {
            const playerCardsContainer = document.getElementById('player-cards');
            playerCardsContainer.innerHTML = '';
            
            // We'll show one card at a time during the battle
            // This will be updated as rounds progress
        }
        
        // Create a card element
        function createCardElement(card, showStats = false) {
            const cardElement = document.createElement('div');
            cardElement.className = 'card';
            cardElement.dataset.id = card.name;
            
            let cardContent = `
                <h3>${card.name}</h3>
                <div class="card-image">
                    <img src="${card.image || ''}" alt="${card.name}" onerror="this.src='{% static 'card_images/do_not_remove.png' %}'">
                </div>
            `;
            
            if (showStats) {
                cardContent += `
                    <div class="card-stats">
                        <div class="stat-row" data-stat="environmental_friendliness">
                            <span class="stat-name">Environment:</span>
                            <span class="stat-value">${card.environmental_friendliness || '?'}</span>
                        </div>
                        <div class="stat-row" data-stat="beauty">
                            <span class="stat-name">Beauty:</span>
                            <span class="stat-value">${card.beauty || '?'}</span>
                        </div>
                        <div class="stat-row" data-stat="cost">
                            <span class="stat-name">Cost:</span>
                            <span class="stat-value">${card.cost || '?'}</span>
                        </div>
                    </div>
                `;
            }
            
            cardElement.innerHTML = cardContent;
            return cardElement;
        }
        
        // Display round result
        function displayRoundResult(data) {
            const p1Card = data.p1_card;
            const p2Card = data.p2_card;
            const result = data.result;
            const stat = data.stat;
            
            // Update scores based on whether player is p1 or p2
            document.getElementById('player-score').textContent = 
                isPlayer1 ? data.player1_score : data.player2_score;
            document.getElementById('opponent-score').textContent = 
                isPlayer1 ? data.player2_score : data.player1_score;
            
            // Display cards played with the correct stat values
            const playerCard = isPlayer1 ? 
                createCardElement({
                    name: p1Card.name,
                    image: p1Card.image,
                    environmental_friendliness: p1Card.stat === 'environmental_friendliness' ? p1Card.value : '?',
                    beauty: p1Card.stat === 'beauty' ? p1Card.value : '?',
                    cost: p1Card.stat === 'cost' ? p1Card.value : '?'
                }, true) : 
                createCardElement({
                    name: p2Card.name,
                    image: p2Card.image,
                    environmental_friendliness: p2Card.stat === 'environmental_friendliness' ? p2Card.value : '?',
                    beauty: p2Card.stat === 'beauty' ? p2Card.value : '?',
                    cost: p2Card.stat === 'cost' ? p2Card.value : '?'
                }, true);
            
            const opponentCard = isPlayer1 ? 
                createCardElement({
                    name: p2Card.name,
                    image: p2Card.image,
                    environmental_friendliness: p2Card.stat === 'environmental_friendliness' ? p2Card.value : '?',
                    beauty: p2Card.stat === 'beauty' ? p2Card.value : '?',
                    cost: p2Card.stat === 'cost' ? p2Card.value : '?'
                }, true) : 
                createCardElement({
                    name: p1Card.name,
                    image: p1Card.image,
                    environmental_friendliness: p1Card.stat === 'environmental_friendliness' ? p1Card.value : '?',
                    beauty: p1Card.stat === 'beauty' ? p1Card.value : '?',
                    cost: p1Card.stat === 'cost' ? p1Card.value : '?'
                }, true);
            
            // Clear and add new cards
            document.getElementById('player-cards').innerHTML = '';
            document.getElementById('opponent-cards').innerHTML = '';
            
            document.getElementById('player-cards').appendChild(playerCard);
            document.getElementById('opponent-cards').appendChild(opponentCard);
            
            // Highlight the stat that was compared
            playerCard.querySelector(`.stat-row[data-stat="${stat}"]`).classList.add('highlight');
            opponentCard.querySelector(`.stat-row[data-stat="${stat}"]`).classList.add('highlight');
            
            // Log the result
            if (result === "tie") {
                logMessage(`Round ${currentRound}: It's a tie! Both players get 1 point.`);
            } else if ((result === "player1" && isPlayer1) || (result === "player2" && !isPlayer1)) {
                logMessage(`Round ${currentRound}: You win this round! You get 3 points.`);
            } else {
                logMessage(`Round ${currentRound}: Your opponent wins this round. They get 3 points.`);
            }
            
            currentRound++;
            
            // Update turn indicator based on player identity
            isMyTurn = (data.next_turn === 1 && isPlayer1) || (data.next_turn === 2 && !isPlayer1);
            updateTurnIndicator();
            
            // If cards remaining is 0, game will end soon
            if (data.cards_remaining <= 0) {
                logMessage("Final round completed! Calculating results...");
            } else {
                // Show the next card for the current player
                if (isMyTurn) {
                    highlightSelectableStats();
                }
            }
        }
        
        // Display battle result
        function displayBattleResult(data) {
            const resultOverlay = document.getElementById('result-overlay');
            const resultTitle = document.getElementById('result-title');
            const resultMessage = document.getElementById('result-message');
            
            let isWinner = false;
            let playerPoints = 0;
            
            if (isPlayer1) {
                isWinner = data.winner === username;
                playerPoints = isWinner ? data.player1_score : data.player2_score;
            } else {
                isWinner = data.winner === username;
                playerPoints = isWinner ? data.player2_score : data.player1_score;
            }
            
            if (isWinner) {
                resultTitle.textContent = "Victory!";
                resultMessage.textContent = `You won the battle and earned ${playerPoints} points!`;
            } else {
                resultTitle.textContent = "Defeat";
                resultMessage.textContent = `You lost the battle. Better luck next time! You still earned ${playerPoints} points.`;
            }
            
            resultOverlay.classList.add('active');
            gameState = "completed";
        }
        
        // Play a card stat
        function playCardStat(stat) {
            if (!isMyTurn || gameState !== "playing") return;
            
            if (socket && socket.readyState === WebSocket.OPEN) {
                const message = {
                    event: 'select_stat',
                    stat: stat
                };
                socket.send(JSON.stringify(message));
                logMessage(`You selected the ${stat} stat for comparison.`);
            }
        }
        
        // Add message to battle log
        function logMessage(message, isError = false) {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            if (isError) logEntry.classList.add('error');
            logEntry.textContent = message;
            
            const battleLog = document.getElementById('battle-log');
            battleLog.appendChild(logEntry);
            battleLog.scrollTop = battleLog.scrollHeight;
        }
        
        // Add this function to update the UI to show whose turn it is
        function updateTurnIndicator() {
            const playerArea = document.querySelector('.player-area');
            const opponentArea = document.querySelector('.opponent-area');
            
            playerArea.classList.toggle('active-turn', isMyTurn);
            opponentArea.classList.toggle('active-turn', !isMyTurn);
            
            // Add status message
            const statusMsg = isMyTurn 
                ? "Your turn! Select a stat to compare." 
                : "Opponent's turn. Waiting for them to select a stat...";
            
            logMessage(statusMsg);
            
            // Make stats selectable if it's the player's turn
            if (isMyTurn) {
                highlightSelectableStats();
            } else {
                // Remove selectable class if it's not the player's turn
                const statRows = document.querySelectorAll('#player-cards .stat-row');
                statRows.forEach(row => {
                    row.classList.remove('selectable');
                });
            }
        }

        // Helper function to make stats selectable when it's the player's turn
        function highlightSelectableStats() {
            if (isMyTurn && gameState === "playing") {
                const statRows = document.querySelectorAll('#player-cards .stat-row');
                statRows.forEach(row => {
                    row.classList.add('selectable');
                    // Add a specific data attribute to mark this as clickable
                    row.setAttribute('data-clickable', 'true');
                });
            }
        }

        // Add this function to render the initial cards
        function renderInitialCards(data) {
            // Create player card with all stats visible
            const playerCard = createCardElement(data.player_card, true);
            document.getElementById('player-cards').innerHTML = '';
            document.getElementById('player-cards').appendChild(playerCard);
            
            // Create opponent card with only name and image
            const opponentCard = createCardElement(data.opponent_card, false);
            document.getElementById('opponent-cards').innerHTML = '';
            document.getElementById('opponent-cards').appendChild(opponentCard);
            
            // Highlight selectable stats if it's the player's turn
            if (isMyTurn) {
                highlightSelectableStats();
            }
        }

        // Set up event listeners when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Connect to WebSocket
            connect();
            
            // Set up confirm selection button
            document.getElementById('confirm-selection').addEventListener('click', confirmCardSelection);
            
            // Set up new battle button on result screen
            document.getElementById('new-battle').addEventListener('click', () => {
                window.location.href = '/battle/';
            });
            
            // Set up stat selection event delegation
            document.querySelector('.battle-area').addEventListener('click', (event) => {
                const statRow = event.target.closest('.stat-row.selectable');
                if (statRow && isMyTurn && gameState === "playing") {
                    const stat = statRow.dataset.stat;
                    playCardStat(stat);
                }
            });
        });
    </script>
</body>
</html>